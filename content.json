{"pages":[{"title":"All tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"防抖节流","text":"算是把防抖节流给整明白了！ 有啥区别？ 定义上：可以简单把防抖理解为延迟触发，把节流理解为控制频率 防抖：监听事件触发，但不立即执行函数，而是最后一次事件触发后，再等待一段时间，若没有再次触发事件，则进行回调函数执行，即事件触发后一段时间内没有再次触发事件，函数才执行 节流：监听事件触发，但不是每个事件触发都会执行函数，而是一次事件触发函数执行后，需等待一段时间，事件的触发才能再次执行函数，即控制一段时间内，函数只允许被执行一次 实现上： 防抖每次事件触发时，都需要取消原先的计时并重新计算延迟时间；节流只有当函数执行时，才需要重新计时 防抖到达延迟时间后，函数自动执行；节流到达计算时间后，需等待事件触发，才可以被执行（可优化） 使用场景？密集的事件触发 输入框中频繁输入内容，搜索或提交信息 鼠标移动事件 用户频繁点击按钮、提交操作登 监听页面滚动事件 监听页面缩放的resize事件 游戏中的一些设计 怎么实现？防抖函数思路 参数：事件触发调用函数+时间 动作： 事件触发，取消原先定时器，重新计时 计时结束，回调函数执行 代码1234567891011121314function debounce(fn, delay) { // 设置定时器 var timer = null; return function () { // 触发事件，清除定时器 if (timer) clearTimeout(timer); // 重新设置定时器 timer = setTimeout(() =&gt; { // 定时结束，函数执行 fn(); clearTimeout(timer); }, delay); };} 节流函数思路 参数：事件触发回调函数+时间 动作： 事件触发，计算当前时刻 计算当前时刻与上一记录时刻的差值 若大于指定时间，则回调函数执行，重新记录当前时刻 若小于指定时间，仍保留上一记录时刻 代码1234567891011121314function throttle(fn, interval) { // 设置初始时刻 let pre = 0; return function () { // 获取当前时刻 const now = new Date().getTime(); // 比较 if (now - pre &gt; interval) { fn(); // 重置上一时刻 pre = now; } };} 如何优化？优化 参数优化：传递事件触发时的参数 this指向优化：this指向绑定事件的节点对象 函数调用优化： 防抖：第一次事件触发时，立即执行回调函数 定时器timer为null，认为是第一次触发函数，立即执行函数 延迟时间到达，函数执行，并且timer重置为null 节流：最后一次事件触发后，执行回调函数 指定时间到达之前触发事件，设置定时器timer，且只需设置一次 指定时间到达之后触发事件，执行函数，且清除定时器，重置timer为null 函数取消优化 函数返回值优化：由于定时器是异步任务，不能直接用return返回 回调函数 promise 防抖函数优化使用promise优化返回值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function debounce(fn, delay, leading = false) { // 设置定时器 var timer = null; var handleEvent = function () { // 返回值优化 return new Promise((resolve, reject) =&gt; { // 触发事件，清除定时器 if (timer) clearTimeout(timer); // 记录this和参数 const _this = this; const _args = arguments; // 使用立即执行优化 if (leading) { // 设定一个参数，判断是否已经立即执行 let isInvoke = false; // timer为null，则事件第一次触发 if (!timer) { resolve(fn.apply(_this, _args)); isInvoke = true; } // 不是第一次触发 // 重新设置定时器 timer = setTimeout(() =&gt; { // 延迟时间一到，设置timer为null，以便下次事件触发可以立即执行 timer = null; // 判断事件是否已经立即执行过了 if (!isInvoke) { resolve(fn.apply(_this, _args)); } }, delay); } else { timer = setTimeout(() =&gt; { resolve(fn.apply(_this, _args)); }, delay); } }); }; // 添加取消功能 handleEvent.cancelEvent = function () { if (timer) { clearTimeout(timer); timer = null; } }; return handleEvent;} 节流函数的优化使用回调函数优化返回值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function throttle(fn, interval, leading = false, callback = null) { // 设置初始时刻 let pre = 0; // 优化最后执行 // 记录计时器是否已开启 let timer = null; let handleEvent = function () { const _this = this; const _args = arguments; // 获取当前时刻 const now = new Date().getTime(); // 使用最后执行 // 比较 if (now - pre &gt; interval) { // 若定时器已开启 // 关闭定时器 if (timer) { clearTimeout(timer); timer = null; } callFn(_this, _args); // 重置上一时刻 pre = now; } else if (timer === null &amp;&amp; leading) { // 在指定时间前触发事件,并且没有开启定时器的情况下 // 只需要开启一个定时器 timer = setTimeout(() =&gt; { callFn(_this, _args); timer = null; }, interval); } }; function callFn(_this, _args) { const res = fn.apply(_this, _args); if (callback) { callback(res); } } // 优化取消 handleEvent.cancelEvent = function () { if(timer){ clearTimeout(timer); timer = null; } }; return handleEvent;}","link":"/2021/12/29/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"}],"tags":[{"name":"优化","slug":"优化","link":"/tags/%E4%BC%98%E5%8C%96/"},{"name":"防抖与节流","slug":"防抖与节流","link":"/tags/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"}],"categories":[{"name":"前端优化","slug":"前端优化","link":"/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"}]}
{"pages":[{"title":"All tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"防抖节流","text":"算是把防抖节流给整明白了！ 有啥区别？ 定义上：可以简单把防抖理解为延迟触发，把节流理解为控制频率 防抖：监听事件触发，但不立即执行函数，而是最后一次事件触发后，再等待一段时间，若没有再次触发事件，则进行回调函数执行，即事件触发后一段时间内没有再次触发事件，函数才执行 节流：监听事件触发，但不是每个事件触发都会执行函数，而是一次事件触发函数执行后，需等待一段时间，事件的触发才能再次执行函数，即控制一段时间内，函数只允许被执行一次 实现上： 防抖每次事件触发时，都需要取消原先的计时并重新计算延迟时间；节流只有当函数执行时，才需要重新计时 防抖到达延迟时间后，函数自动执行；节流到达计算时间后，需等待事件触发，才可以被执行（可优化） 使用场景？密集的事件触发 输入框中频繁输入内容，搜索或提交信息 鼠标移动事件 用户频繁点击按钮、提交操作登 监听页面滚动事件 监听页面缩放的resize事件 游戏中的一些设计 怎么实现？防抖函数思路 参数：事件触发调用函数+时间 动作： 事件触发，取消原先定时器，重新计时 计时结束，回调函数执行 代码1234567891011121314function debounce(fn, delay) { // 设置定时器 var timer = null; return function () { // 触发事件，清除定时器 if (timer) clearTimeout(timer); // 重新设置定时器 timer = setTimeout(() =&gt; { // 定时结束，函数执行 fn(); clearTimeout(timer); }, delay); };} 节流函数思路 参数：事件触发回调函数+时间 动作： 事件触发，计算当前时刻 计算当前时刻与上一记录时刻的差值 若大于指定时间，则回调函数执行，重新记录当前时刻 若小于指定时间，仍保留上一记录时刻 代码1234567891011121314function throttle(fn, interval) { // 设置初始时刻 let pre = 0; return function () { // 获取当前时刻 const now = new Date().getTime(); // 比较 if (now - pre &gt; interval) { fn(); // 重置上一时刻 pre = now; } };} 如何优化？优化 参数优化：传递事件触发时的参数 this指向优化：this指向绑定事件的节点对象 函数调用优化： 防抖：第一次事件触发时，立即执行回调函数 定时器timer为null，认为是第一次触发函数，立即执行函数 延迟时间到达，函数执行，并且timer重置为null 节流：最后一次事件触发后，执行回调函数 指定时间到达之前触发事件，设置定时器timer，且只需设置一次 指定时间到达之后触发事件，执行函数，且清除定时器，重置timer为null 函数取消优化 函数返回值优化：由于定时器是异步任务，不能直接用return返回 回调函数 promise 防抖函数优化使用promise优化返回值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function debounce(fn, delay, leading = false) { // 设置定时器 var timer = null; var handleEvent = function () { // 返回值优化 return new Promise((resolve, reject) =&gt; { // 触发事件，清除定时器 if (timer) clearTimeout(timer); // 记录this和参数 const _this = this; const _args = arguments; // 使用立即执行优化 if (leading) { // 设定一个参数，判断是否已经立即执行 let isInvoke = false; // timer为null，则事件第一次触发 if (!timer) { resolve(fn.apply(_this, _args)); isInvoke = true; } // 不是第一次触发 // 重新设置定时器 timer = setTimeout(() =&gt; { // 延迟时间一到，设置timer为null，以便下次事件触发可以立即执行 timer = null; // 判断事件是否已经立即执行过了 if (!isInvoke) { resolve(fn.apply(_this, _args)); } }, delay); } else { timer = setTimeout(() =&gt; { resolve(fn.apply(_this, _args)); }, delay); } }); }; // 添加取消功能 handleEvent.cancelEvent = function () { if (timer) { clearTimeout(timer); timer = null; } }; return handleEvent;} 节流函数的优化使用回调函数优化返回值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function throttle(fn, interval, leading = false, callback = null) { // 设置初始时刻 let pre = 0; // 优化最后执行 // 记录计时器是否已开启 let timer = null; let handleEvent = function () { const _this = this; const _args = arguments; // 获取当前时刻 const now = new Date().getTime(); // 使用最后执行 // 比较 if (now - pre &gt; interval) { // 若定时器已开启 // 关闭定时器 if (timer) { clearTimeout(timer); timer = null; } callFn(_this, _args); // 重置上一时刻 pre = now; } else if (timer === null &amp;&amp; leading) { // 在指定时间前触发事件,并且没有开启定时器的情况下 // 只需要开启一个定时器 timer = setTimeout(() =&gt; { callFn(_this, _args); timer = null; }, interval); } }; function callFn(_this, _args) { const res = fn.apply(_this, _args); if (callback) { callback(res); } } // 优化取消 handleEvent.cancelEvent = function () { if(timer){ clearTimeout(timer); timer = null; } }; return handleEvent;}","link":"/2021/12/29/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"},{"title":"懒加载：图片懒加载","text":"从接触前端优化开始，懒加载便经常出现在查阅的各种资料，但一直没有时间对他进行系统学习和代码实现。前端优化的话题始终绕不过懒加载这个基本方法，因此，接下来的时间，会围绕懒加载进一步学习，今天就先从最简单的图片懒加载开始！ 啥是懒加载？ 也叫延迟加载，对于页面有很多静态资源的情况下（比如网商购物页面），为了节省用户流量和提高页面性能，可以在用户浏览到当前资源的时候，再对资源进行请求和加载。 有啥作用？ 减少无效资源的加载 减少等待时间，提升用户的体验 防止并发加载的资源过多会阻塞js的加载 如何实现图片懒加载?原理 图片src属性设置为空或默认图片地址 自定义属性data-src储存真正的图片地址 监听页面滚动事件,若图片进入可视区域,src替换成data-src内容 封装的API Jquery插件jquery_lazyload:https://github.com/tuupola/jquery_lazyload 阮一峰 lozad.js:https://github.com/ApoorvSaxena/lozad.js 简单实现滚动事件频繁触发,可以与防抖函数相结合 防抖:https://cainanya.github.io/2021/12/29/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import { debounceFn } from './防抖.js';export async function lazyload(selector = '.lazyload', defaultSrc = '') { // 初始化默认图片 function setDefaultImage(defaultSrc) { return new Promise((resolve, reject) =&gt; { let images = document.querySelectorAll(selector); let temp = new Image(); temp.src = defaultSrc; console.log(images); temp.onload = function () { for (let item of images) { item.src = defaultSrc; } resolve(true); }; }); } // 懒加载操作 // 获取屏幕可视区 let clientH = document.documentElement.clientHeight; function load() { // 获取图片元素 let images = document.querySelectorAll(selector); for (let img of images) { // 获取真正地址 let dataSrc = img.getAttribute('data-src'); if (dataSrc === '') continue; // 获取元素距离屏幕位置 let rect = img.getBoundingClientRect(); // 判断是否在可视区内 if (rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; clientH) { // 创建一个加载图片的临时 let temp = new Image(); temp.src = dataSrc; temp.onload = function () { img.src = temp.src; }; // 移除元素类名，下次不再加载 let s = selector.replace(/.|#/, ''); console.log(s); img.classList.remove(s); img.removeAttribute('data-src'); } } } if (defaultSrc !== '') { await setDefaultImage(defaultSrc); } // 加载页面，立即执行 load(); // 滚动执行，与防抖函数结合 const loadFn = debounceFn(load, 200); window.addEventListener('scroll', loadFn);}","link":"/2021/12/31/%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"title":"flex布局","text":"捋一捋flex布局。 flex布局的诞生传统网页布局大多采用盒子模型，依赖display、position定位，float浮动，在这种模式下，实现特殊的布局十分不方便，由此，W3C提出一种更加灵活、直接的布局方案，flex布局应运而生。 flex布局的思想flex容器中存在一根主轴，撑满容器宽度，定义了flex项目排布的方向，影响对其方式。 flex容器中还存在与主轴垂直的交叉轴，当只有一行flex项目时，交叉轴只有一根，且撑满容器高度。 当有多行flex项目时，交叉轴有多根，可理解为有多少行，就有多少根交叉轴，默认情况下，多根交叉轴铺满容器高度，可以通过align-content修改交叉轴对其方式 flex布局的属性设置flex布局的属性设置可以分为两个方面：容器上的设置、项目上的设置。直接上图说明： 需要注意的地方： align-item设置的是项目在其交叉轴上的对应方式，align-content设置的是多个交叉轴的对其方式，且只有存在多个交叉轴时才起作用 容器设为 Flex 布局以后，项目的float、clear和vertical-align属性将失效","link":"/2022/01/13/flex%E5%B8%83%E5%B1%80/"},{"title":"html5和css3","text":"学习前端一年多以来，一直都有在写页面，写样式和布局，却没有好好系统的了解哪些是css3和html5的新特性，导致面试问的时候都不知道该怎么回答，因此找了一篇总结较为全面的文章进行系统的学习。 直接上一个总结的很好的链接： https://juejin.cn/post/6844903829679390728#heading-13","link":"/2022/01/16/html5%E5%92%8Ccss3/"}],"tags":[{"name":"优化","slug":"优化","link":"/tags/%E4%BC%98%E5%8C%96/"},{"name":"防抖与节流","slug":"防抖与节流","link":"/tags/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"},{"name":"懒加载","slug":"懒加载","link":"/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"name":"flex布局","slug":"flex布局","link":"/tags/flex%E5%B8%83%E5%B1%80/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"html","slug":"html","link":"/tags/html/"}],"categories":[{"name":"前端优化","slug":"前端优化","link":"/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"html","slug":"css/html","link":"/categories/css/html/"}]}